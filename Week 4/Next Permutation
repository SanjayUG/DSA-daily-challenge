/*
Given an array of integers representing a permutation of numbers, rearrange the numbers into the next lexicographically greater permutation.

If such arrangement is not possible (i.e., it’s the highest permutation), rearrange it to the lowest possible order (sorted ascending).

You must do it in-place and use only O(1) extra space.

✅ Example
Input: [1,2,3]
Output: [1,3,2]



*/


/*
function nextPermutation(nums):
    n = length(nums)
    
    # Step 1: find pivot
    i = n-2
    while i >= 0 and nums[i] >= nums[i+1]:
        i--

    if i >= 0:
        # Step 2: find successor
        j = n-1
        while nums[j] <= nums[i]:
            j--
        swap(nums[i], nums[j])

    # Step 3: reverse suffix
    reverse(nums, i+1, n-1)



*/


class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length;
        int i = n - 2;

        // Step 1: Find first decreasing element
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }

        if (i >= 0) {
            // Step 2: Find element just larger than nums[i]
            int j = n - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }

        // Step 3: Reverse suffix
        reverse(nums, i + 1, n - 1);
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    private void reverse(int[] nums, int start, int end) {
        while (start < end) {
            swap(nums, start, end);
            start++;
            end--;
        }
    }
}
