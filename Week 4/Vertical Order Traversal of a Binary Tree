/*
Given the root of a binary tree, return its vertical order traversal.

Nodes that are in the same vertical column should appear together.

If two nodes are in the same row and column, order them by left-to-right.

If the problem explicitly asks for sorted vertical traversal (LeetCode 987), then you also sort by value when row and column are same.

Input:
       3
      / \
     9   20
        /  \
       15   7

Output: [[9], [3, 15], [20], [7]]


*/


/*
function verticalOrder(root):
    if root is null: return []

    map = {}   # column -> list of nodes
    queue = [(root, 0)]
    minCol = 0, maxCol = 0

    while queue not empty:
        node, col = queue.pop()
        map[col].append(node.val)
        minCol = min(minCol, col)
        maxCol = max(maxCol, col)

        if node.left:
            queue.push((node.left, col - 1))
        if node.right:
            queue.push((node.right, col + 1))

    result = []
    for col in range(minCol, maxCol+1):
        result.append(map[col])

    return result



*/


import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}

class Solution {
    public List<List<Integer>> verticalOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) return result;

        Map<Integer, List<Integer>> map = new HashMap<>();
        Queue<Pair> queue = new LinkedList<>();
        queue.offer(new Pair(root, 0));

        int minCol = 0, maxCol = 0;

        while (!queue.isEmpty()) {
            Pair curr = queue.poll();
            TreeNode node = curr.node;
            int col = curr.col;

            map.putIfAbsent(col, new ArrayList<>());
            map.get(col).add(node.val);

            minCol = Math.min(minCol, col);
            maxCol = Math.max(maxCol, col);

            if (node.left != null) queue.offer(new Pair(node.left, col - 1));
            if (node.right != null) queue.offer(new Pair(node.right, col + 1));
        }

        for (int i = minCol; i <= maxCol; i++) {
            result.add(map.get(i));
        }

        return result;
    }

    class Pair {
        TreeNode node;
        int col;
        Pair(TreeNode node, int col) {
            this.node = node;
            this.col = col;
        }
    }
}
