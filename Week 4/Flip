/*
You are given a binary string s (only '0' and '1').
You may choose at most one substring and flip all its characters (0 → 1, 1 → 0).

Your task is to return the 1-based indices [L, R] of the substring that maximizes the number of 1s in the final string.

If the string is already all 1s, return an empty array.
Input: "010"
Output: [1, 1]

Explanation:
Flipping the first bit → "110", which has maximum 1s.


*/


/*
function flip(s):
    arr = []
    for ch in s:
        if ch == '0':
            arr.append(1)
        else:
            arr.append(-1)

    maxSum = 0
    currentSum = 0
    L = R = start = 0
    for i in range(len(arr)):
        if currentSum + arr[i] < arr[i]:
            currentSum = arr[i]
            start = i
        else:
            currentSum += arr[i]

        if currentSum > maxSum:
            maxSum = currentSum
            L = start
            R = i

    if maxSum <= 0:
        return []

    return [L+1, R+1]   # 1-based index



*/

import java.util.*;

class Solution {
    public ArrayList<Integer> flip(String A) {
        int n = A.length();
        int maxSum = 0, currSum = 0;
        int l = 0, r = 0, start = 0;
        int bestL = -1, bestR = -1;

        for (int i = 0; i < n; i++) {
            int val = (A.charAt(i) == '0') ? 1 : -1;

            if (currSum + val < val) {
                currSum = val;
                start = i;
            } else {
                currSum += val;
            }

            if (currSum > maxSum) {
                maxSum = currSum;
                bestL = start;
                bestR = i;
            }
        }

        ArrayList<Integer> ans = new ArrayList<>();
        if (bestL == -1) return ans; // all 1s
        ans.add(bestL + 1); // convert to 1-based
        ans.add(bestR + 1);
        return ans;
    }
}

