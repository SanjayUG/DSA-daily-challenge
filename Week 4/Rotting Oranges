/*
You are given a grid where:

0 = empty cell

1 = fresh orange

2 = rotten orange

Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.

Return the minimum number of minutes needed for all oranges to rot.
If impossible â†’ return -1.

Input: 
grid = [[2,1,1],
        [1,1,0],
        [0,1,1]]

Output: 4



*/


/*

function orangesRotting(grid):
    rows, cols = dimensions of grid
    queue = empty queue
    fresh = 0

    for each cell in grid:
        if cell == 2:
            add (row, col, 0) to queue
        if cell == 1:
            fresh++

    time = 0
    directions = [(1,0), (-1,0), (0,1), (0,-1)]

    while queue not empty:
        r, c, t = queue.pop()
        time = max(time, t)

        for each (dr, dc) in directions:
            nr = r + dr, nc = c + dc
            if inside grid and grid[nr][nc] == 1:
                grid[nr][nc] = 2
                fresh--
                queue.push((nr, nc, t+1))

    if fresh > 0:
        return -1
    return time


*/



import java.util.*;

class Solution {
    public int orangesRotting(int[][] grid) {
        int rows = grid.length, cols = grid[0].length;
        Queue<int[]> queue = new LinkedList<>();
        int fresh = 0;

        // Add all rotten oranges to queue
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                if (grid[r][c] == 2) {
                    queue.offer(new int[]{r, c, 0}); // (row, col, time)
                } else if (grid[r][c] == 1) {
                    fresh++;
                }
            }
        }

        int time = 0;
        int[][] directions = {{1,0}, {-1,0}, {0,1}, {0,-1}};

        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int r = curr[0], c = curr[1], t = curr[2];
            time = Math.max(time, t);

            for (int[] d : directions) {
                int nr = r + d[0], nc = c + d[1];
                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == 1) {
                    grid[nr][nc] = 2;
                    fresh--;
                    queue.offer(new int[]{nr, nc, t + 1});
                }
            }
        }

        return (fresh == 0) ? time : -1;
    }
}
