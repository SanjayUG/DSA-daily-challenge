/*
You are given an integer array nums.
Find the shortest continuous subarray that, if you sort it, makes the whole array sorted in ascending order.

Return the length of this subarray.
Input: [2, 6, 4, 8, 10, 9, 15]
Output: 5
Explanation: Sorting subarray [6, 4, 8, 10, 9] makes the array sorted.


*/

/*
function findUnsortedSubarray(nums):
    n = length(nums)
    l = 0, r = n-1

    # step 1: find left boundary
    while l < n-1 and nums[l] <= nums[l+1]:
        l++

    # array sorted
    if l == n-1:
        return 0

    # step 2: find right boundary
    while r > 0 and nums[r] >= nums[r-1]:
        r--

    # step 3: find min & max inside l..r
    subMin = min(nums[l..r])
    subMax = max(nums[l..r])

    # step 4: expand boundaries
    while l > 0 and nums[l-1] > subMin:
        l--
    while r < n-1 and nums[r+1] < subMax:
        r++

    return r - l + 1



*/


class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int n = nums.length;
        int l = 0, r = n - 1;

        // find left boundary
        while (l < n - 1 && nums[l] <= nums[l + 1]) {
            l++;
        }

        if (l == n - 1) return 0; // already sorted

        // find right boundary
        while (r > 0 && nums[r] >= nums[r - 1]) {
            r--;
        }

        // find min and max in the subarray
        int subMin = Integer.MAX_VALUE, subMax = Integer.MIN_VALUE;
        for (int i = l; i <= r; i++) {
            subMin = Math.min(subMin, nums[i]);
            subMax = Math.max(subMax, nums[i]);
        }

        // expand left
        while (l > 0 && nums[l - 1] > subMin) {
            l--;
        }
        // expand right
        while (r < n - 1 && nums[r + 1] < subMax) {
            r++;
        }

        return r - l + 1;
    }
}
