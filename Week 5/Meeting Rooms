/*
1. Given an array of meeting time intervals intervals[i] = [start, end], determine if a person can attend all meetings (no overlap).


*/

/*
function canAttendMeetings(intervals):
    sort intervals by start time
    for i = 1 to intervals.length-1:
        if intervals[i].start < intervals[i-1].end:
            return false
    return true



*/


import java.util.*;

public class MeetingRooms {
    public boolean canAttendMeetings(int[][] intervals) { // intervals = [[0,30],[5,10],[15,20]]

        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] < intervals[i - 1][1]) {
                return false; // overlap
            }
        }
        return true;
    }
}

________


/*
2. Given meeting intervals, find the minimum number of meeting rooms required


*/


/*
function minMeetingRooms(intervals):
    sort intervals by start time
    minHeap = new priorityQueue()  // stores end times

    for each interval in intervals:
        if heap not empty AND heap.peek() <= interval.start:
            heap.poll()   // reuse room
        heap.add(interval.end)

    return heap.size()



*/


import java.util.*;

public class MeetingRoomsII {
    public int minMeetingRooms(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int[] interval : intervals) {
            if (!minHeap.isEmpty() && minHeap.peek() <= interval[0]) {
                minHeap.poll(); // room is free
            }
            minHeap.add(interval[1]); // allocate current meeting
        }
        return minHeap.size();
    }
}
