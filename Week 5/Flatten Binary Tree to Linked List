/*
Given the root of a binary tree, flatten it into a linked list in-place.

The flattened tree should follow the same order as preorder traversal (Root → Left → Right).

The left child of all nodes should be null.

The right child should point to the next node in the preorder traversal.

        1
       / \
      2   5
     / \   \
    3   4   6
to
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6


*/


/*
function flatten(root):
    curr = root

    while curr != null:
        if curr.left != null:
            // Find rightmost node of left subtree
            rightmost = curr.left
            while rightmost.right != null:
                rightmost = rightmost.right

            // Attach current's right subtree to rightmost
            rightmost.right = curr.right

            // Move left subtree to right
            curr.right = curr.left
            curr.left = null

        // Move forward
        curr = curr.right



*/


class Solution {
    public void flatten(TreeNode root) {
        TreeNode curr = root;

        while (curr != null) {
            if (curr.left != null) {
                // Find the rightmost node of left subtree
                TreeNode rightmost = curr.left;
                while (rightmost.right != null) {
                    rightmost = rightmost.right;
                }

                // Connect right subtree to rightmost
                rightmost.right = curr.right;

                // Move left subtree to right
                curr.right = curr.left;
                curr.left = null;
            }
            // Move forward
            curr = curr.right;
        }
    }
}
