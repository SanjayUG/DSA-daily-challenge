/*
Given an integer array A, find the largest continuous subsequence whose sum = 0.
Return the subsequence (not just the length).
If multiple answers exist, return the one that appears first.
Example

Input:

A = [1, 2, -2, 4, -4]


Output:

[2, -2, 4, -4]

*/


/*
function lszero(A):
    map = {0: -1}
    sum = 0
    maxLen = 0
    start, end = -1, -1

    for i in range(0, n):
        sum += A[i]

        if sum in map:
            prevIndex = map[sum]
            length = i - prevIndex
            if length > maxLen:
                maxLen = length
                start = prevIndex + 1
                end = i
        else:
            map[sum] = i

    result = []
    if start == -1: return result
    for j in range(start, end+1):
        result.add(A[j])

    return result


*/


import java.util.*;

class Solution {
    public ArrayList<Integer> lszero(ArrayList<Integer> A) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        int maxLen = 0;
        int start = -1, end = -1;

        map.put(0, -1); // prefix sum = 0 at index -1

        for (int i = 0; i < A.size(); i++) {
            sum += A.get(i);

            if (map.containsKey(sum)) {
                int prevIndex = map.get(sum);
                int length = i - prevIndex;
                if (length > maxLen) {
                    maxLen = length;
                    start = prevIndex + 1;
                    end = i;
                }
            } else {
                map.put(sum, i);
            }
        }

        ArrayList<Integer> result = new ArrayList<>();
        if (start == -1) return result; // no subarray
        for (int i = start; i <= end; i++) {
            result.add(A.get(i));
        }
        return result;
    }
}
